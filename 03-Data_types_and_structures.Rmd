# Data types and data structures

In this chapter, we will cover the following topics -

* Data type
  + Numbers
  + Characters
  + Logical
* Data structure
  + Vector
  + Matrix
  + Array
  + Data frame
  + List
* Import and export data
  + .txt
  + .csv
  + .xlsx
* Manipulating data


## Useful data types in R

There are different data types used in *R*. We will touch upon a few but heavily used data types in this class. These are namely - 


### Numbers: 
Numbers can be an Integers, or can be floating numbers (decimal numbers). They are recognized as simple `Numeric` data type in *R*. 

###  Character: 
This type of data can be equivalent to categorical variable. In other programming language, this is equivalent to *String* or *Text* data type. Here in *R*, these can be nominal (just names) or ordinal (names with hidden order) variables. 

### Logical: 
such as True or False. These can be the result of a boolean operation. 

Letâ€™s see an example - 

```{r, echo=F, warning=FALSE, message=FALSE}
library(knitr)
library(kableExtra)
library(dplyr)
kable(
  data.frame(
    "participant ID"=c("BMI1_001", "BMI1_002", "BMI1_003"),
    Date=c("01/11/2021", "02/11/2021", "03/11/2021"), 
    "weight in kg"=c(55.5,45,75), "height in cm"=c(172,165,150),
    smoker=c("No", "Yes", "No"),
    "Overall health-condition"=c("Intermediate", "Good", "Poor")
    ), 
  format = "html") %>%
  kable_styling(
    bootstrap_options = "striped", 
    full_width = F, 
    position = "left"
    )
```
Here in the table above, *participant.ID*, *smoker*, *Overall.health.condition* columns represent character data type. Of them, *participant.ID* and *smoker* columns contain nominal data, while the *Overall.health.condition* represents the ordinal data type.

The columns namely *weight.in.kg* and	*height.in.cm* contain numeric data type. 

A very very important information - 
Categorical data (nominal or ordinal) in *R* are also called *Factors*. Sometimes, you need to detach this characteristic (i.e. being factors) from your data and convert it to merely character type for the sake of data handling. 

```{r}
Overall.health.condition <- factor(c("Intermediate", "Good", "Poor", "Good", "Poor" ))
Overall.health.condition
#~~~~~~~~~~~~~~~~~~~~
Overall.health.condition <- factor(c("Intermediate", "Good", "Poor", "Good", "Poor"), 
                                   ordered = F)
Overall.health.condition
#~~~~~~~~~~~~~~~~~~~~
Overall.health.condition <- factor(c("Intermediate", "Good", "Poor", "Good", "Poor"), 
                                   ordered = T)
Overall.health.condition
#~~~~~~~~~~~~~~~~~~~~
Overall.health.condition <- factor(c("Intermediate", "Good", "Poor", "Good", "Poor"), 
                                   ordered = T, 
                                   levels = c("Poor", "Intermediate", "Good"))
Overall.health.condition
```

There are also *complex* data types, *date* data types etc, which we will not cover in this course.


## Data structure

There are few useful pre-defined data structures heavily used in *R* and there are user defined data structures as well (there are no limits in this case). We will discuss a few of the former class -


### Vector: 
Let's first think of a variable and value pair, like you have a variable `x` and it has a value of `2`. Like what we write in *R*: 
`x <- 2`, which means, we assign the value `2` to `x`. This is equivalent to a *scalar*. 
You can put more than one value in a variable, and then it will be equivalent to a *vector*: 
```
y <- c(1,2,3,4,5,6)
``` 
Here we have used the *combine function* `c()` to create a vector. Vector can hold different data-types individually, that means, one vector can hold only one type of data (numeric or character or logical etc). Just remember, if you want to hold multiple elements (be it numeric values or characters), enclose them with the *combine function* (as above).

Each of the component of the vector is called its *Element*. You can call or refer the elements individually or as a group using their *positional index*. The positional index starts from `1`, which you can refer to as *one-based indexing*. For example, if you want to call or retrieve the first element of vector `y`, you can type in `y[1]`. Similarly, you can refer to the 4th element by typing in `y[4]`. If you want to refer to from 2nd to the 4th elements of `y`, you type in `y[c(2,3,4)]` or you can use `y[2:4]`. 

A useful tip - for sequential numbers, you can use a short-cut using colon sign in between the minimum and maximum values (inclusive) of the range. Like, for 1 to 100, you type in `1:100`.


### Matrix: 
A matrix is a two-dimensional (row and column) array of a single data type. Matrices are created using `matrix()` function. Think of you having 20 numbers, from 1 to 20 and you want to create a matrix with 4 rows and 5 columns. So you type in:
```{r}
myMatrix <- matrix(data=1:20,nrow = 4,ncol = 5)
myMatrix
```
If you want to subset the matrix you can do it easily. Always remember, matrix is a `m` row by `n` column `(m x n)` structure which you define in *R* as `[m,n]` or `[row, column]`. If you want to choose the value in the first row and the first column (which also indicates numeric `1` in myMatrix), you type in `myMatrix[1,1]`. If you want to select first 2 rows and 2nd to 4th columns, you type in `myMatrix[c(1,2), c(2,3,4)]` or `myMatrix[1:2, 2:4]`.

### Array: 
You can accommodate your data in more than 2 dimensions using an array. We will not cover it in this course.


### Data frame: 
For you, data frame is the main data type that will have a vast utility in this course. You will import data in this format and manipulate data and export data in this format. Therefore, it's imperative that you understand it very carefully. A data frame is a two-dimensional array. It is more general than a matrix and can contain different data types in it at the same time. However, each column contains a single data type (of course). The function to create a data frame is `data.frame()` and an easy way to create a data frame is 
```
myDataFrame <- data.frame(column1, column2, column3))
```
Let's see the same data frame again and observe carefully how it is done. 

```{r}
participant.ID=c("BMI1_001", "BMI1_002", "BMI1_003")
Date=c("01/11/2021", "01/11/2021", "01/11/2021")
weight.in.kg=c(55.5,45,75)
height.in.cm=c(172,165,150)
smoker=c("No", "Yes", "No")
Overall.health.condition=c("Intermediate", "Good", "Poor")

myDataFrame <- data.frame(participant.ID, Date, weight.in.kg, height.in.cm, smoker, Overall.health.condition)

myDataFrame
```

Remember, each of the vector defining each column in the data frame has to be of same length. Now, if you want to subset the data frame as you did from matrix, you can use the same technique. For example, if you want to know the weight and height of first two patients, you type in `myDataFrame[c(1,2),c(3,4)]`. Interestingly in the case of data frame, you can use the column names to do that, like -
```
myDataFrame[c(1,2),c("weight.in.kg", "height.in.cm")]
``` 
Further more, there is another level of flexibility for selecting a column information by using `dataframe$columnName` notation as in our case `myDataFrame$weight.in.kg`.

Now, you can inquire what are the column names by utilizing `colnames()` function and for the row names - `rownames()`, of course. Here, in this case, we don't have row names yet, but we can assign them with `row1`, `row2` and `row2` by typing in 
```
rownames(myDataFrame) <-  c("row1", "row2", "row3")
```

Now, if we want to subset using row and column names, we can type in -
```
myDataFrame[c("row1","row2"),c("weight.in.kg", "height.in.cm")]
```

Important nomenclature alert: In the realm of statistics, we refer a row as an *observation* and a column as a *variable.* In the realm of data analysts, they are *records* and *fields*, respectively. And, in the realm of Machine Learning, they are *examples* and *attributes*, respectively

### List: 
In *R*, List is the (arguably) the most complex data structure which can hold different data types and data structures. Even, a list can hold another list. We will not cover this data structure in this course. 


## Import and export data

For this course, we will limit ourselves to import data from our personal computers. I have sent two different files to you - one with `.txt` extension and another with `.csv`. First we will deal with our `example_data.txt` file and to import it, we will use `read.table()` function. And for `example_data.csv` file, we will use `read.csv()` function. 

For exporting the file, we will use either `write.table()` function or `write.csv()` function. 

To deal with *.xls* or .*xlsx* files, we will touch on this topic when we discuss how to *load packages*, later.





The basic mode of reading a tabular dataset is the `read.table()` function. There are few others, like read.csv(), read.csv2(), read.ftable(), read.delim() etc. There are some basic parameter that you should be careful on -

1. file = /path/to/the/file
2. header = the default is set to `TRUE`, however, if the data doesn't have a column name, set it to false.
3. sep = for `read.table()`, it is set to white space. For `read.csv()`, it is a comma. For `read.csv2()`, it's set to a semi-colon. For `read.delim()` or `read.delim2()`, it's is a tab `"\t"`.
4. row.names = if there's a column for row name (usually the first column in the raw data), specify with the column number and later get rid of that column using say, data[,column_number] <- NULL


```{r}
# read a tabular dataframe

```


Now, reading a csv file -

```{r}

```

What about excel files?

```{r}
#library(readxl)
# list the sheets of the excel file
#excel_sheets('Sample-Sales-Data.xlsx')
#df <- read_excel('Sample-Sales-Data.xlsx',sheet='Sheet1')


```

How to check after each read-in?

```{r}
# dimension of the data
# check the head or tail
# apply str() and summary() function 
```

reading in files from the web -

```{r}
# from CRUK ML course
```





How to write the output into csv, tab or xls files -

```{r}
# write.table()
# write.csv()
# library(xlsx)
# df <- data.frame(matrix(1:10))
# #write.xlsx(df, "output.xlsx")

```




## Manipulating data

```{r}
# use mtcars dataframe
# selecting columns by numerical indexing or column names
# implementing average of each columns, sum of each column, colSums etc
# add NA value to the dataframe, check for NA using is.na() function and then do the same operations with na.rm=TRUE argument.

```

## Exercise